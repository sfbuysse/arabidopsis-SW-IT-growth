for (i in 1:length(genos)){
area_by_geno[[22+i]] <- rosarea[(rosarea$Geno == genos[i]& rosarea$Trt == trts[2]), ]
}
area_by_geno <- area_by_geno[c(1,3,4,6:44)]
# run a model for each item in the area_by_geno list
# df to save slopes
slopes <- data.frame(Geno = c(genos[c(1,3,4,6:22)], genos),
Trt = as.factor(c(rep("Cur", times = 20), rep("Fut", times = 22))),
Beta = rep(NA, times = 42))
slopes$uniqueID <- paste0(slopes$Trt, slopes$Geno )
slopes$Pop <- factor("SW", levels = c("SW", "IT"))
slopes[as.numeric(slopes$Geno) < 11, "Pop" ] <- "IT"
for (j in 1:length(area_by_geno)){
tmp <- lm(log_area ~ DaysFromEmergence, data = area_by_geno[[j]])
# do any of the models fit well? commented out but decent
#hist(residuals(tmp))
#plot(fitted(tmp), residuals(tmp, type = "pearson", scaled = TRUE))
slopes$Beta[j] <- tmp[["coefficients"]][["DaysFromEmergence"]]
# model data
#modData = tmp$coefficients[1]+area_by_geno[[j]]$DaysFromEmergence*tmp$coefficients[2]
## look at the model-predicted data curve on top of the actual data
#plot(area_by_geno[[j]]$DaysFromEmergence, area_by_geno[[j]]$log_area, bty="n", col="darkgray")
#points(area_by_geno[[j]]$DaysFromEmergence, modData,col="red",lwd=2)
}
# add quad to initial model
slopes2 <- data.frame(Geno = c(genos[c(1,3,4,6:22)], genos),
Trt = as.factor(c(rep("Cur", times = 20), rep("Fut", times = 22))),
Beta = rep(NA, times = 42),
gamma = rep(NA, times = 42))
slopes2$uniqueID <- paste0(slopes$Trt, slopes$Geno )
slopes2$Pop <- factor("SW", levels = c("SW", "IT"))
slopes2[as.numeric(slopes2$Geno) < 11, "Pop" ] <- "IT"
for (j in 1:length(area_by_geno)){
tmp <- lm(log_area ~ DaysFromEmergence + quad_date, data = area_by_geno[[j]])
# do any of the models fit well? commented plots our but yes
#hist(residuals(tmp))
#plot(fitted(tmp), residuals(tmp, type = "pearson", scaled = TRUE))
slopes2$Beta[j] <- tmp[["coefficients"]][["DaysFromEmergence"]]
slopes2$gamma[j] <- tmp[["coefficients"]][["quad_date"]]
slopes2$intercept[j] <- tmp[["coefficients"]][["(Intercept)"]]
# model data
#
#modData = tmp$coefficients[1]+as.numeric(area_by_geno[[j]]$DaysFromEmergence)*tmp$coefficients[2] + as.numeric(area_by_geno[[j]]$quad_date)*tmp$coefficients[3]
## look at the model-predicted data curve on top of the actual data
#plot(area_by_geno[[j]]$DaysFromEmergence, area_by_geno[[j]]$log_area, bty="n", col="darkgray")
#points(area_by_geno[[j]]$DaysFromEmergence, modData,col="red",lwd=2)
}
# step 2 model for linear step 1
final_mod <- lm(Beta ~ Trt * Pop, data = slopes, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod))
plot(fitted(final_mod), residuals(final_mod, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes$Pop)],
pch = c(16, 5)[as.numeric(slopes$Trt)])
# I think this is better
summary(final_mod)
# estimated marginal means for plotting
slope_means <- as.data.frame(emmeans(final_mod, specs = c("Trt", "Pop")))
# plot. mean is the predicted value.
ggplot(data = slopes, aes(y = Beta, x = Trt))+
geom_point(aes(col = Pop), alpha = 0.6, shape = 16, position = position_jitter(width = .3, height = 0), size = 2)+
geom_point(data = slope_means, aes(x = Trt, y = emmean, fill = Pop),position = position_dodge(width = 0.1), alpha = 0.8, shape = 21, size = 3)+ # big point for pop means
geom_errorbar(data = slope_means, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop),position = position_dodge(width = 0.1), width = 0.1, size = 0.8, show.legend = TRUE)+
#geom_line(data = slope_means, aes(group = Pop, col = Pop), size = 1)+
labs(x = "Treatment")+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))
# without log, Italy has two low outliers in Cur that don't appear when log transformed.
final_mod2_beta <- lm(Beta ~ Trt * Pop, data = slopes2, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod2_beta))
plot(fitted(final_mod2_beta), residuals(final_mod2_beta, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes2$Pop)],
pch = c(16, 5)[as.numeric(slopes2$Trt)])
summary(final_mod2_beta)
# all the standard errors for each term are identical
final_mod2_gamma <- lm(gamma ~ Trt * Pop, data = slopes2, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod2_gamma))
plot(fitted(final_mod2_gamma), residuals(final_mod2_gamma, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes2$Pop)],
pch = c(16, 5)[as.numeric(slopes2$Trt)])
summary(final_mod2_gamma)
final_mod2_int <- lm(intercept ~ Trt * Pop, data = slopes2, contrasts = list(Trt=contr.sum, Pop = contr.sum))
# estimated marginal means for plotting
slope2_means <- as.data.frame(emmeans(final_mod2_beta, specs = c("Trt", "Pop")))
slope2_gammas <- as.data.frame(emmeans(final_mod2_gamma, specs = c("Trt", "Pop")))
slope2_intercepts <- as.data.frame(emmeans(final_mod2_int, specs = c("Trt", "Pop")))
# plot. mean is the predicted value... that is good and makes sense?
beta_leafarea <- ggplot(data = slopes2, aes(y = Beta, x = Trt))+
geom_point(aes(col = Pop, fill = Pop, shape = Pop), alpha = 0.6, position = position_jitter(width = .3, height = 0), size = 2)+
geom_errorbar(data = slope2_means, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop),position = position_dodge(width = 0.5), width = 0.3, size = 0.8, show.legend = FALSE)+
geom_point(data = slope2_means, aes(x = Trt, y = emmean, fill = Pop, shape = Pop),position = position_dodge(width = 0.5), size = 3)+ # big point for pop means
labs(x = "Treatment", y = expression(paste("Leaf Area :  ", beta)))+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_shape_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c(24, 21))
gamma_leafarea <- ggplot(data = slopes2, aes(y = gamma, x = Trt))+
geom_point(aes(col = Pop, fill = Pop, shape = Pop), alpha = 0.6, position = position_jitter(width = .3, height = 0), size = 2)+
geom_errorbar(data = slope2_gammas, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop), position = position_dodge(width = 0.5), width = 0.3, size = 0.8, show.legend = FALSE)+
geom_point(data = slope2_gammas, aes(x = Trt, y = emmean, fill = Pop, shape = Pop), position = position_dodge(width = 0.5), size = 3)+ # big point for pop means
labs(x = "Treatment", y = expression(paste("Leaf Area :  ", gamma)))+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_shape_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c(24, 21))
#would need to create a custom function for each line
RosAreaTime$log_area <- log(RosAreaTime$LeafArea)
trends_leafarea <- ggplot(data = RosAreaTime, aes(x = DaysFromEmergence, y = log_area))+
geom_line(aes(group = grp, col = Population, linetype = Trt), size = 0.4, alpha = 0.3, show.legend = TRUE)+
geom_function(fun = function(x) slope2_intercepts$emmean[1] + slope2_means$emmean[1]*x + slope2_gammas$emmean[1]*x^2, colour = "#009E73", linetype = "solid", xlim=c(0, 100), size = 0.9)+ # Cur SW
geom_function(fun = function(x) slope2_intercepts$emmean[2] + slope2_means$emmean[2]*x + slope2_gammas$emmean[2]*x^2, colour = "#009E73", linetype = "dotdash", xlim=c(0, 100), size = 0.9)+ # Fut SW
geom_function(fun = function(x) slope2_intercepts$emmean[3] + slope2_means$emmean[3]*x + slope2_gammas$emmean[3]*x^2, colour = "#CC79A7", linetype = "solid", xlim=c(0, 100), size = 0.9)+ # Cur IT
geom_function(fun = function(x) slope2_intercepts$emmean[4] + slope2_means$emmean[4]*x + slope2_gammas$emmean[4]*x^2, colour = "#CC79A7", linetype = "dotdash", xlim=c(0, 100), size = 0.9)+ # Fut IT
geom_segment(aes(x = 0, xend = 25, y = -3.5, yend = -3.5), col = "#D55E00", size = 1)+
geom_segment(aes(x = 25, xend = 81, y = -3.5, yend = -3.5), col = "#56B4E9", size = 1)+
geom_segment(aes(x = 81, xend = 102, y = -3.5, yend = -3.5), col = "#F0E442", size = 1)+
labs(x = "Days After Planting", y = "Log Leaf Area")+
scale_color_manual(name = "Population",
labels = c("IT", "SW"),
values = c("#CC79A7", "#009E73"))+
scale_linetype_manual(name = "Treatment",
labels = c("Current", "Future"),
values = c("solid", "dotdash"))
trends_leafarea
beta_leafarea
gamma_leafarea
# remove NAs
rosnum <- LeafNumTime[complete.cases(LeafNumTime), ]
# remove zeros
rosnum <- rosnum[!(rosnum$LeafNum == 0), ]
# make geno a factor
rosnum$Geno <- as.factor(rosnum$Geno)
# add log transformed column
rosnum$log_ln <- log(rosnum$LeafNum)
# plot trends by grouping factor
ggscatter(
rosnum, x = "Date2", y = "LeafNum",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
ggscatter(
rosnum, x = "Date2", y = "log_ln",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
# by Days Since Emergence
ggscatter(
rosnum, x = "DaysFromEmergence", y = "LeafNum",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
ggscatter(
rosnum, x = "DaysFromEmergence", y = "log_ln",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
# add quadratic term, no scaling
rosnum$quad_date <- rosnum$DaysFromEmergence^2
# make a list of dataframes where each dataframe is the leaf areas for one genotype
ln_by_geno <- list(rep(NA, times = 44))
genos_ln <- unique(rosnum$Geno)
trts_ln <- unique(rosnum$Trt)
# current
for (i in 1:22){
ln_by_geno[[i]] <- rosnum[(rosnum$Geno == genos_ln[i]& rosnum$Trt == trts_ln[1]), ]
}
# 102 and 105 again have no data
# fut
for (i in 1:length(genos_ln)){
ln_by_geno[[22+i]] <- rosnum[(rosnum$Geno == genos_ln[i]& rosnum$Trt == trts_ln[2]), ]
}
ln_by_geno <- ln_by_geno[c(1,3,4,6:44)]
# run a model for each item in the ln_by_geno list
slopes_ln <- data.frame(Geno = c(genos[c(1,3,4,6:22)], genos),
Trt = as.factor(c(rep("Cur", times = 20), rep("Fut", times = 22))),
Beta = rep(NA, times = 42))
slopes_ln$uniqueID <- paste0(slopes_ln$Trt, slopes_ln$Geno )
slopes_ln$Pop <- factor("SW", levels = c("SW", "IT"))
slopes_ln[as.numeric(slopes_ln$Geno) < 11, "Pop" ] <- "IT"
for (j in 1:length(ln_by_geno)){
tmp <- lm(LeafNum ~ DaysFromEmergence, data = ln_by_geno[[j]])
# do any of the models fit well?
#hist(residuals(tmp))
#plot(fitted(tmp), residuals(tmp, type = "pearson", scaled = TRUE))
slopes_ln$Beta[j] <- tmp[["coefficients"]][["DaysFromEmergence"]]
# model data
modData = tmp$coefficients[1]+ln_by_geno[[j]]$DaysFromEmergence*tmp$coefficients[2]
## look at the model-predicted data curve on top of the actual data
#plot(ln_by_geno[[j]]$DaysFromEmergence, ln_by_geno[[j]]$LeafNum, bty="n", col="darkgray")
#points(ln_by_geno[[j]]$DaysFromEmergence, modData,col="red",lwd=2)
}
# check quadratic
slopes2_ln <- data.frame(Geno = c(genos[c(1,3,4,6:22)], genos),
Trt = as.factor(c(rep("Cur", times = 20), rep("Fut", times = 22))),
Beta = rep(NA, times = 42),
gamma = rep(NA, times = 42))
slopes2_ln$uniqueID <- paste0(slopes_ln$Trt, slopes_ln$Geno )
slopes2_ln$Pop <- factor("SW", levels = c("SW", "IT"))
slopes2_ln[as.numeric(slopes2_ln$Geno) < 11, "Pop" ] <- "IT"
for (j in 1:length(ln_by_geno)){
tmp <- lm(LeafNum ~ DaysFromEmergence + quad_date, data = ln_by_geno[[j]])
# do any of the models fit well?
#hist(residuals(tmp))
#plot(fitted(tmp), residuals(tmp, type = "pearson", scaled = TRUE))
slopes2_ln$Beta[j] <- tmp[["coefficients"]][["DaysFromEmergence"]]
slopes2_ln$gamma[j] <- tmp[["coefficients"]][["quad_date"]]
slopes2_ln$intercept[j] <- tmp[["coefficients"]][["(Intercept)"]]
# model data
#modData = tmp$coefficients[1]+as.numeric(ln_by_geno[[j]]$DaysFromEmergence)*tmp$coefficients[2] + as.numeric(ln_by_geno[[j]]$quad_date)*tmp$coefficients[3]
## look at the model-predicted data curve on top of the actual data
#plot(ln_by_geno[[j]]$DaysFromEmergence, ln_by_geno[[j]]$LeafNum, bty="n", col="darkgray")
#points(ln_by_geno[[j]]$DaysFromEmergence, modData,col="red",lwd=2)
}
# actual model for linear step 1
final_mod_ln <- lm(Beta ~ Trt * Pop, data = slopes_ln, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod_ln))
plot(fitted(final_mod_ln), residuals(final_mod_ln, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes_ln$Pop)],
pch = c(16, 5)[as.numeric(slopes_ln$Trt)])
summary(final_mod_ln)
# estimated marginal means for plotting
slope_ln_means <- as.data.frame(emmeans(final_mod_ln, specs = c("Trt", "Pop")))
# plot. mean is the predicted value.
ggplot(data = slopes_ln, aes(y = Beta, x = Trt))+
geom_point(aes(col = Pop), alpha = 0.6, shape = 16, position = position_jitter(width = .3, height = 0), size = 2)+
geom_point(data = slope_ln_means, aes(x = Trt, y = emmean, fill = Pop),position = position_dodge(width = 0.5), alpha = 0.8, shape = 21, size = 3)+ # big point for pop means
geom_errorbar(data = slope_ln_means, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop),position = position_dodge(width = 0.5), width = 0.1, size = 0.8, show.legend = TRUE)+
#geom_line(data = slope_means, aes(group = Pop, col = Pop), size = 1)+
labs(x = "Treatment")+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))
final_mod2_ln_beta <- lm(Beta ~ Trt * Pop, data = slopes2_ln, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod2_ln_beta))
plot(fitted(final_mod2_ln_beta), residuals(final_mod2_ln_beta, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes2_ln$Pop)],
pch = c(16, 5)[as.numeric(slopes2_ln$Trt)])
summary(final_mod2_ln_beta)
# all the standard errors for each term are identical
final_mod2_ln_gamma <- lm(gamma ~ Trt * Pop, data = slopes2_ln, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod2_ln_gamma))
plot(fitted(final_mod2_ln_gamma), residuals(final_mod2_ln_gamma, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes2_ln$Pop)],
pch = c(16, 5)[as.numeric(slopes2_ln$Trt)])
summary(final_mod2_ln_gamma)
final_mod2_ln_int <- lm(intercept ~ Trt * Pop, data = slopes2_ln, contrasts = list(Trt=contr.sum, Pop = contr.sum))
# estimated marginal means for plotting
slope2_ln_means <- as.data.frame(emmeans(final_mod2_ln_beta, specs = c("Trt", "Pop")))
slope2_ln_gammas <- as.data.frame(emmeans(final_mod2_ln_gamma, specs = c("Trt", "Pop")))
slope2_ln_intercepts <- as.data.frame(emmeans(final_mod2_ln_int, specs = c("Trt", "Pop")))
# plot
beta_leafnum <- ggplot(data = slopes2_ln, aes(y = Beta, x = Trt))+
geom_point(aes(col = Pop, fill = Pop, shape = Pop), alpha = 0.6, position = position_jitter(width = .3, height = 0), size = 2)+
geom_errorbar(data = slope2_ln_means, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop),position = position_dodge(width = 0.5), width = 0.3, size = 0.8, show.legend = FALSE)+
geom_point(data = slope2_ln_means, aes(x = Trt, y = emmean, fill = Pop, shape = Pop),position = position_dodge(width = 0.5), size = 3)+ # big point for pop means
labs(x = "Treatment", y = expression(paste("Leaf Number :  ", beta)))+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_shape_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c(24, 21))
gamma_leafnum <- ggplot(data = slopes2_ln, aes(y = gamma, x = Trt))+
geom_point(aes(col = Pop, fill = Pop, shape = Pop), alpha = 0.6, position = position_jitter(width = .3, height = 0), size = 2)+
geom_errorbar(data = slope2_ln_gammas, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop),position = position_dodge(width = 0.5), width = 0.3, size = 0.8, show.legend = FALSE)+
geom_point(data = slope2_ln_gammas, aes(x = Trt, y = emmean, fill = Pop, shape = Pop),position = position_dodge(width = 0.5), size = 3)+ # big point for pop means
labs(x = "Treatment", y = expression(paste("Leaf Number :  ",gamma)))+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_shape_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c(24, 21))
trends_leafnum <- ggplot(data = LeafNumTime, aes(x = DaysFromEmergence, y = LeafNum))+
geom_line(aes(group = grp, col = Population, linetype = Trt), size = 0.4, alpha = 0.3, show.legend = TRUE)+
geom_function(fun = function(x) slope2_ln_intercepts$emmean[1] + slope2_ln_means$emmean[1]*x + slope2_ln_gammas$emmean[1]*x^2, colour = "#009E73", linetype = "solid", xlim=c(0, 100), size = 0.9)+ # Cur SW
geom_function(fun = function(x) slope2_ln_intercepts$emmean[2] + slope2_ln_means$emmean[2]*x + slope2_ln_gammas$emmean[2]*x^2, colour = "#009E73", linetype = "dotdash", xlim=c(0, 100), size = 0.9)+ # Fut SW
geom_function(fun = function(x) slope2_ln_intercepts$emmean[3] + slope2_ln_means$emmean[3]*x + slope2_ln_gammas$emmean[3]*x^2, colour = "#CC79A7", linetype = "solid", xlim=c(0, 100), size = 0.9)+ # Cur IT
geom_function(fun = function(x) slope2_ln_intercepts$emmean[4] + slope2_ln_means$emmean[4]*x + slope2_ln_gammas$emmean[4]*x^2, colour = "#CC79A7", linetype = "dotdash", xlim=c(0, 100), size = 0.9)+ # Fut IT
geom_segment(aes(x = 0, xend = 25, y = -2, yend = -2), col = "#D55E00", size = 1)+
geom_segment(aes(x = 25, xend = 81, y = -2, yend = -2), col = "#56B4E9", size = 1)+
geom_segment(aes(x = 81, xend = 102, y = -2, yend = -2), col = "#F0E442", size = 1)+
labs(x = "Days After Emergence", y = "Leaf Number")+
scale_color_manual(name = "Population",
labels = c("IT", "SW"),
values = c("#CC79A7", "#009E73"))+
scale_linetype_manual(name = "Treatment",
labels = c("Current", "Future"),
values = c("solid", "dotdash"))
trends_leafnum
beta_leafnum
gamma_leafnum
# remove NAs
totnum <- TotalNumTime[complete.cases(TotalNumTime), ]
# remove zeros
totnum <- totnum[!(totnum$TotalNum == 0), ]
# make geno a factor
totnum$Geno <- as.factor(totnum$Geno)
# add log transformed column
totnum$log_tn <- log(totnum$TotalNum)
# plot trends by grouping factor
ggscatter(
totnum, x = "Date2", y = "TotalNum",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
ggscatter(
totnum, x = "Date2", y = "log_tn",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
ggscatter(
totnum, x = "DaysFromEmergence", y = "TotalNum",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
ggscatter(
totnum, x = "DaysFromEmergence", y = "log_tn",
facet.by  = c("Population", "Trt"),
short.panel.labs = FALSE
)+
stat_smooth(method = "loess", span = 0.9)
# add quadratic term, no scaling
totnum$quad_date <- totnum$DaysFromEmergence^2
# make a list of dataframes where each dataframe is the leaf areas for one genotype
tn_by_geno <- list(rep(NA, times = 44))
genos_tn <- unique(totnum$Geno)
trts_tn <- unique(totnum$Trt)
# current
for (i in 1:22){
tn_by_geno[[i]] <- totnum[(totnum$Geno == genos_ln[i]& totnum$Trt == trts_ln[1]), ]
}
# future
for (i in 1:length(genos_tn)){
tn_by_geno[[22+i]] <- totnum[(totnum$Geno == genos_ln[i]& totnum$Trt == trts_ln[2]), ]
}
tn_by_geno <- tn_by_geno[c(1,3,4,6:44)]
# run a model for each item in the area_by_geno list
slopes_tn <- data.frame(Geno = c(genos[c(1,3,4,6:22)], genos),
Trt = as.factor(c(rep("Cur", times = 20), rep("Fut", times = 22))),
Beta = rep(NA, times = 42))
slopes_tn$uniqueID <- paste0(slopes_tn$Trt, slopes_tn$Geno )
slopes_tn$Pop <- factor("SW", levels = c("SW", "IT"))
slopes_tn[as.numeric(slopes_tn$Geno) < 11, "Pop" ] <- "IT"
for (j in 1:length(tn_by_geno)){
tmp <- lm(TotalNum ~ DaysFromEmergence, data = tn_by_geno[[j]])
# do any of the models fit well?
#hist(residuals(tmp))
#plot(fitted(tmp), residuals(tmp, type = "pearson", scaled = TRUE))
slopes_tn$Beta[j] <- tmp[["coefficients"]][["DaysFromEmergence"]]
# model data
#modData = tmp$coefficients[1]+tn_by_geno[[j]]$DaysFromEmergence*tmp$coefficients[2]
## look at the model-predicted data curve on top of the actual data
#plot(tn_by_geno[[j]]$DaysFromEmergence, tn_by_geno[[j]]$TotalNum, bty="n", col="darkgray")
#points(tn_by_geno[[j]]$DaysFromEmergence, modData,col="red",lwd=2)
}
# check quadratic
slopes2_tn <- data.frame(Geno = c(genos[c(1,3,4,6:22)], genos),
Trt = as.factor(c(rep("Cur", times = 20), rep("Fut", times = 22))),
Beta = rep(NA, times = 42),
gamma = rep(NA, times = 42))
slopes2_tn$uniqueID <- paste0(slopes_tn$Trt, slopes_tn$Geno )
slopes2_tn$Pop <- factor("SW", levels = c("SW", "IT"))
slopes2_tn[as.numeric(slopes2_tn$Geno) < 11, "Pop" ] <- "IT"
for (j in 1:length(tn_by_geno)){
tmp <- lm(TotalNum ~ DaysFromEmergence + quad_date, data = tn_by_geno[[j]])
# do any of the models fit well?
#hist(residuals(tmp))
#plot(fitted(tmp), residuals(tmp, type = "pearson", scaled = TRUE))
slopes2_tn$Beta[j] <- tmp[["coefficients"]][["DaysFromEmergence"]]
slopes2_tn$gamma[j] <- tmp[["coefficients"]][["quad_date"]]
slopes2_tn$intercept[j] <- tmp[["coefficients"]][["(Intercept)"]]
# model data
#modData = tmp$coefficients[1]+as.numeric(tn_by_geno[[j]]$DaysFromEmergence)*tmp$coefficients[2] + as.numeric(tn_by_geno[[j]]$quad_date)*tmp$coefficients[3]
## look at the model-predicted data curve on top of the actual data
#plot(tn_by_geno[[j]]$DaysFromEmergence, tn_by_geno[[j]]$TotalNum, bty="n", col="darkgray")
#points(tn_by_geno[[j]]$DaysFromEmergence, modData,col="red",lwd=2)
}
final_mod2_tn_beta <- lm(Beta ~ Trt * Pop, data = slopes2_tn, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod2_tn_beta))
plot(fitted(final_mod2_tn_beta), residuals(final_mod2_tn_beta, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes2_tn$Pop)],
pch = c(16, 5)[as.numeric(slopes2_tn$Trt)])
summary(final_mod2_tn_beta)
# all the standard errors for each term are identical
final_mod2_tn_gamma <- lm(gamma ~ Trt * Pop, data = slopes2_tn, contrasts = list(Trt=contr.sum, Pop = contr.sum))
hist(residuals(final_mod2_tn_gamma))
plot(fitted(final_mod2_tn_gamma), residuals(final_mod2_tn_gamma, type = "pearson", scaled = TRUE),
col = c("red", "blue")[as.numeric(slopes2_tn$Pop)],
pch = c(16, 5)[as.numeric(slopes2_tn$Trt)])
summary(final_mod2_tn_gamma)
final_mod2_tn_int <- lm(intercept ~ Trt * Pop, data = slopes2_tn, contrasts = list(Trt=contr.sum, Pop = contr.sum))
# estimated marginal means for plotting
slope2_tn_means <- as.data.frame(emmeans(final_mod2_tn_beta, specs = c("Trt", "Pop")))
slope2_tn_gammas <- as.data.frame(emmeans(final_mod2_tn_gamma, specs = c("Trt", "Pop")))
slope2_tn_intercepts <- as.data.frame(emmeans(final_mod2_tn_int, specs = c("Trt", "Pop")))
# plot
beta_totalnum <- ggplot(data = slopes2_tn, aes(y = Beta, x = Trt))+
geom_point(aes(col = Pop, fill = Pop, shape = Pop), alpha = 0.6, position = position_jitter(width = .3, height = 0), size = 2)+
geom_errorbar(data = slope2_tn_means, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop),position = position_dodge(width = 0.5), width = 0.3, size = 0.8, show.legend = FALSE)+
geom_point(data = slope2_tn_means, aes(x = Trt, y = emmean, fill = Pop, shape = Pop),position = position_dodge(width = 0.5), size = 3)+ # big point for pop means
labs(x = "Treatment")+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_shape_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c(24, 21))
gamma_totalnum <- ggplot(data = slopes2_tn, aes(y = gamma, x = Trt))+
geom_point(aes(col = Pop, fill = Pop, shape = Pop), alpha = 0.6, position = position_jitter(width = .3, height = 0), size = 2)+
geom_errorbar(data = slope2_tn_gammas, aes(x = Trt, y = emmean, ymin=lower.CL, ymax = upper.CL, col = Pop),position = position_dodge(width = 0.5), width = 0.3, size = 0.8, show.legend = FALSE)+
geom_point(data = slope2_tn_gammas, aes(x = Trt, y = emmean, fill = Pop, shape = Pop),position = position_dodge(width = 0.5), size = 3)+ # big point for pop means
labs(x = "Treatment", y = "Gamma")+
scale_color_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_fill_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c("#009E73", "#CC79A7"))+
scale_shape_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c(24, 21))
trends_totalnum <- ggplot()+
geom_function(fun = function(x) slope2_tn_intercepts$emmean[1] + slope2_tn_means$emmean[1]*x + slope2_tn_gammas$emmean[1]*x^2, colour = "#009E73", linetype = "solid", xlim=c(0, 100))+ # Cur SW
geom_function(fun = function(x) slope2_tn_intercepts$emmean[2] + slope2_tn_means$emmean[2]*x + slope2_tn_gammas$emmean[2]*x^2, colour = "#009E73", linetype = "dotdash", xlim=c(0, 100))+ # Fut SW
geom_function(fun = function(x) slope2_tn_intercepts$emmean[3] + slope2_tn_means$emmean[3]*x + slope2_tn_gammas$emmean[3]*x^2, colour = "#CC79A7", linetype = "solid", xlim=c(0, 100))+ # Cur IT
geom_function(fun = function(x) slope2_tn_intercepts$emmean[4] + slope2_tn_means$emmean[4]*x + slope2_tn_gammas$emmean[4]*x^2, colour = "#CC79A7", linetype = "dotdash", xlim=c(0, 100))+ # Fut IT
labs(x = "Days After Emergence", y = "Total Leaf Number")
trends_totalnum
beta_totalnum
gamma_totalnum
figure <- ggarrange(trends_leafarea+rremove("xlab"), beta_leafarea+rremove("xlab"), gamma_leafarea+rremove("xlab"),
trends_leafnum, beta_leafnum+rremove("xlab"), gamma_leafnum+rremove("xlab"),
labels = c("A", "B", "C", "D", "E", "F", "G", "H", "I"),
ncol = 3, nrow = 2,
widths = c(1, 0.49, 0.51 ),
common.legend = TRUE, # goes based on the first plot
legend = "top",
align = "hv")
# needs a 4:3 aspect ratio
ggsave(figure, filename = "../figures/Micropub_figure.jpg", width = 8, height = 6, units = "in", dpi = 500)
# top legend
legend_points2 <- data.frame(xvals = c(1, 1.5), yvals = c(1, 1), text = c("Italy", "Sweden"), Pop = as.factor(c("IT", "SW")))
legend_fig <- ggplot()+
geom_point(data = legend_points2, aes(x = xvals, y = yvals, fill = Pop, shape = Pop), size = 4, show.legend = FALSE)+
geom_segment(aes(x = 2.2, y = 1, xend = 2.7, yend = 1), linetype = "solid", linewidth = 1.25)+
geom_segment(aes(x = 3.2, y = 1, xend = 3.7, yend = 1), linetype = "dotdash", linewidth = 1.25)+
geom_text(aes(x = c(1.2, 1.8, 2.9, 3.9), y = c(1, 1, 1, 1), label = c("Italy", "Sweden", "Current", "Future")))+
scale_color_manual(name = "Population",
labels = c("IT", "SW"),
values = c("#CC79A7", "#009E73"))+
scale_fill_manual(name = "Population",
labels = c("IT", "SW"),
values = c("#CC79A7", "#009E73"))+
scale_shape_manual(name = "Population",
labels = c("Sweden", "Italy"),
values = c(21, 24))+
xlim(c(0.87, 4.12))+
theme_void()
legend_fig
# for updating figure legend after
ggsave(legend_fig, filename = "../figures/legend.png", dpi = 500, width = 8, height = 0.5, units = "in")
View(rosarea)
View(rosnum)
check.cor <- merge(rosarea, rosnum, by = c("PotLabel", "Flat", "Pos", "Trt", "Geno", "Population", "grp", "EmergenceDate", "BoltingDate", "Date", "Date2", "DaysFromEmergence", "quad_date"), all = TRUE )
View(check.cor)
check.cor <- merge(rosarea, rosnum, by = c("PotLabel", "Flat", "Pos", "Trt", "Geno", "Population", "grp", "EmergenceDate", "BoltingDate", "Date", "Date2", "DaysFromEmergence", "quad_date"), all = FALSE )
check.cor <- merge(rosarea, rosnum, by = c("PotLabel", "Flat", "Pos", "Trt", "Geno", "Population", "grp", "EmergenceDate", "BoltingDate", "Date", "Date2", "DaysFromEmergence", "quad_date"), all = TRUE )
check.cor <- merge(rosarea, rosnum, by = c("PotLabel", "Flat", "Pos", "Trt", "Geno", "Population", "grp", "EmergenceDate", "BoltingDate", "Date", "Date2", "DaysFromEmergence", "quad_date"), all = FALSE )
View(check.cor)
cor.test(check.cor$LeafArea, check.cor$LeafNum)
cor.test(check.cor$log_area, check.cor$LeafNum)
check.cor <- merge(rosarea, rosnum, by = c("PotLabel", "Flat", "Pos", "Trt", "Geno", "Population", "grp", "EmergenceDate", "BoltingDate", "Date", "Date2", "DaysFromEmergence", "quad_date"), all = TRUE )
# there is a lot of measurements with different days (1427 obs when all = TRUE) but still 768 observations only counting days where both measured on the same day
cor.test(check.cor$LeafArea, check.cor$LeafNum) # r = 0.8566571, p<2.2e-16
cor.test(check.cor$log_area, check.cor$LeafNum) # r = 0.8311089, p<2.2e-16
check.cor <- merge(rosarea, rosnum, by = c("PotLabel", "Flat", "Pos", "Trt", "Geno", "Population", "grp", "EmergenceDate", "BoltingDate", "Date", "Date2", "DaysFromEmergence", "quad_date"), all = FALSE )
# there is a lot of measurements with different days (1427 obs when all = TRUE) but still 768 observations only counting days where both measured on the same day
cor.test(check.cor$LeafArea, check.cor$LeafNum) # r = 0.8566571, p<2.2e-16
cor.test(check.cor$log_area, check.cor$LeafNum) # r = 0.8311089, p<2.2e-16
